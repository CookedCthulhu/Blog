
# Vectorization has come a long way in .NET

SIMD/Vectorization is largely regarded as an expert level feature that should only be used if the application's performance budget is so tight that you can justify the additional development time and mental overhead that comes with it. It's not only difficult to read but the same code has to be implemented multiple times for multiple platforms with a fallback if the customer's CPU doesn't support it.

Over the Christmas holidays I had the chance to port a personal project from .NET 6 to .NET 7 and gave vectorization a second look. I don't think the above statement it 100% true anymore. Let me give you an example, a simple `Color` struct with two methods: `Equals` and `AlphaBlend`, which just a simple textbook implementation of layering two pixels on top of each other.

```c#
[StructLayout(LayoutKind.Sequential)]
public readonly struct Color
{
    // Alpha
    public float A { get; }
    // Red
    public float R { get; }
    // Green
    public float G { get; }
    // Blue
    public float B { get; }

    // constructor omitted

    public Color AlphaBlend(Color top) => new(
        top.A + A * (1 - top.A),
        top.R + R * (1 - top.A),
        top.G + G * (1 - top.A),
        top.B + B * (1 - top.A));

    public bool Equals(Color other) => 
           A == other.A
        && R == other.R
        && G == other.G
        && B == other.B;
}

```

I did implement a vectorized version of `AlphaBlend` prior to C# 11 for performance and curiosity. It wasn't pretty. `Color` is a struct of four 32 bit `float`s, which is 128 bit in total, the same size as `Vector128<float>`. `Vector64<T>`, `Vector128<T>` and `Vector256<T>` are special data structures known to the JIT compiler and they can only hold primitives, like `int`, `long` or `float`. Other types will fail at compile- or runtime. There is also `Vector<T>` in `System.Numerics` with an unspecified size. To perform operations on a `Vector128`, you have to use the functions defined in the `Sse`/`Avx` static classes. These will fail at runtime if the host's CPU doesn't support them and it's up to you to implement a fallback solution.

```c#
// Don't destroy the performance gains before doing the actual calculation.
public Vector128<float> Vec128 => Unsafe.As<ColorF32, Vector128<float>>(ref Unsafe.AsRef(in this));

public Color AlphaBlend(Color top) 
{
    if (Sse.IsSupported)
    {
        var vResult = Sse.Multiply(Vec128, Vector128.Create(1.0f - top.A));
        vResult = Sse.Add(vResult, top.Vec128);
        return new(vResult);
    }
    else
    {
        return new(
            a: top.A + A * (1 - top.A),
            r: top.R + R * (1 - top.A),
            g: top.G + G * (1 - top.A),
            b: top.B + B * (1 - top.A));
    }
}

```

Are those unsafe casts safe? The unit test say yes but I'm not sure I would risk it in production. It doesn't support ARM CPUs and looks even scarier in languages that have to fall back to metaprogramming to eliminate the if-else branch. At least C#'s JIT is smart enough to detect such patterns and rewrite the function at runtime.

But with C# 11 you don't have to do that anymore. The `Vector` classes have their own operators now! It's a small change that has a massive impact on readability and maintainability. The vectorized version is now on par with the scalar version in terms of readability, and even a little shorter.

```c#
public readonly struct Color
{
    private readonly Vector128<float> argb;

    public Vector128<float> Vector => argb;
    // Alpha
    public float A => argb.GetElement(0);
    // Red
    public float R => argb.GetElement(1);
    // Green
    public float G => argb.GetElement(2);
    // Blue
    public float B => argb.GetElement(3);

    // constructor omitted

    public Color AlphaBlend(Color top) => new(Vector * Vector128.Create(1.0f - top.A) + top.Vector);

    public bool Equals(Color other) => Vector == other.Vector;
}

```

Are there still functions that cannot be implemented this way? Of course. But the next time you write a simple container of homogenous data, stop and think for a second if you could express it as a `Vector` internally. Maybe someone will thank you for your extra care someday, or at least learn something new.
