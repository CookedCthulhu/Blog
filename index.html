<!doctype html>
<html lang="en-US">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="A blog about various topics related to programming and art. Author: Philipp Schmid; Functional Programming, SIMD, Vectorization, Digital Painting, CSharp, C#">
    <meta name="theme-color" content="#16433d"/>
    <link rel="stylesheet" href="default-reset.css">
    <link rel="stylesheet" href="default-styles.css">
    <link rel="stylesheet" href="default-header.css">
    <link rel="stylesheet" href="default-code.css">
    <link rel="stylesheet" href="default-table.css">
    <link rel="stylesheet" href="media-highres.css">
    <link rel="stylesheet" href="media-mobile.css">
    <link rel="stylesheet" href="media-sidenav.css">
    <title>Cooked Cthulhu's Blog</title>
  </head>
  <body>
        <div class="header-nonsticky"></div>
        <div class="header">
        <div class="sidenav code">
            <div><a href="#bitonic-merge">About fast merge algorithms</a></div>
            <div><a href="#taming-d3">Making D3 readable</a></div>
            <div><a href="#vectorization-net-7">Vectorization in .NET 7</a></div>
            <div><a href="#haskell-io">Haskell was right</a></div>
            <div><a href="#about-me">About</a></div>
        </div>
        <div><h3>Home</h1></div>
        <svg preserveAspectRatio="none" viewBox="0 0 100 30">
            <path fill="#16433d" d="
                m-20, 10
                c 10, 0 5, 13 13, 13
                c 10, 0 12, -10 24, -10
                c 10, 0 12,  10 24, 10
                c 10, 0 12, -10 24, -10
                c 10, 0 12,  10 24, 10
                c 10, 0 12, -10 24, 0
                L 100 0
                L 0 0">
            </path>
        </svg>
    </div>
    <div class="header-shadow"></div>

    <div class="textarea" id="bitonic-merge">
        <h2>About fast merge algorithms</h2>
        <p>There's surprisingly little information on the internet about how to merge two sorted arrays. Yes, there are probably thousands of research papers about sorting, including merge sort, but what if you want to just merge two arrays? Sorting is often in place and assumes that the arrays similar in size, which wasn't suitable for my specific use case. <a href="https://dirtyhandscoding.wordpress.com/2017/08/02/vectorizing-stdmerge-with-vpermd-from-avx2-and-lookup-table/">I did however find this C++ approach</a>. It's an impressive solution that uses AVX2 and lookup tables to reduce execution time to about 40% of the trivial approach. Let's see if we can get lower than that.</p>
        <p>The following samples are in C#, not C++, and therefore not comparable. A direct comparison would be interesting but this blog post is quite long already.</p>
        <h3>A Baseline</h3>
        <p>Let's take a look at the trivial algorithm first. We start at zero for all indices, compare two elements each iteration and write the smaller one to the result array. Increment either <span class="code-inline">idxA</span> or <span class="code-inline">idxB</span>, always increment the result index. Repeat until one input has no more elements left. Copy the raminder of the other array.</p>
        <div class="code">
            <p class="indent-0">static void MergeScalar&lt;T, TComparer&gt;&lpar;</p>
            <p class="indent-1">Span&lt;T&gt; a,</p>
            <p class="indent-1">Span&lt;T&gt; b,</p>
            <p class="indent-1">Span&lt;T&gt; result,</p>
            <p class="indent-1">TComparer comparer&rpar;</p>
            <p class="indent-1">where TComparer : IComparer&lt;T&gt;</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">if (a.Length + b.Length > result.Length)</p>
            <p class="indent-2">throw new ArgumentException("...");</p>
            <br>
            <p class="indent-1">var idxA = 0;</p>
            <p class="indent-1">var idxB = 0;</p>
            <p class="indent-1">var idxR = 0;</p>
            <br>
            <p class="indent-1">while (idxA &lt; a.Length && idxB &lt; b.Length)</p>
            <p class="indent-1">&lbrace;</p>
            <p class="indent-2">var c = comparer.Compare(a[idxA], b[idxB]);</p>
            <br>
            <p class="indent-2">if (c &lt;= 0)</p>
            <p class="indent-2">&lbrace;</p>
            <p class="indent-3">result[idxR] = a[idxA];</p>
            <p class="indent-3">idxA++;</p>
            <p class="indent-2">&rbrace;</p>
            <p class="indent-2">else</p>
            <p class="indent-2">&lbrace;</p>
            <p class="indent-3">result[idxR] = a[idxB];</p>
            <p class="indent-3">idxB++;</p>
            <p class="indent-2">&rbrace;</p>
            <p class="indent-2">idxR++;</p>
            <br>
            <p class="indent-1">if (c &lt;= 0)</p>
            <p class="indent-1">&lbrace;</p>
            <p class="indent-2">a.Slice(idxA).CopyTo(result.Slice(idxR));</p>
            <p class="indent-1">&rbrace;</p>
            <p class="indent-1">else</p>
            <p class="indent-1">&lbrace;</p>
            <p class="indent-2">b.Slice(idxB).CopyTo(result.Slice(idxR));</p>
            <p class="indent-1">&rbrace;</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>Not too difficult. Done. But is it even worth to write a merge algorithm in 2024 when you could just concatenate two arrays and sort them? Quicksort and all its variations are probably the most researched and optimized topic in computer science.</p>
        <div class="table benchmark">
            <h4>Random sorted integers</h4>
            <p>Method</p><p>n</p><p>Mean</p><p>Error</p><p>StdDev</p><p>Ratio</p>
            <p>Sorted</p><p>100000</p><p>6938.9 us</p><p>76.12 us</p><p>71.21 us</p><p>1.00</p>
            <p>Scalar</p><p>100000</p><p> 992.1 us</p><p>12.22 us</p><p>11.43 us</p><p>0.14</p>
        </div>
        <p>Neat! While the results aren't too surprising, it's nice to see a simple but specialized algorithm beat the optimized but lazy method. Can we do better?</p>
        <h3>Branchless SIMD Merge</h3>
        <p>I'm quite proud of this one. I don't claim to be the first who found it but I came up with it completely on my own. It's an extension of the scalar version, which exploits the possibility that the larger array contains more elements clumped together. The code from this point on is specific to integers but should be simple to extend to any data type that supports vectorization.</p>
        <p>The base structure is similar to the scalar one, except that we operate on raw pointers, which is required by <span class="code-inline">Vector256.Load</span> and should also eliminate a couple of bounds checks.</p>
        <div class="code">
            <p class="indent-0">static void MergeVectorized(Span&lt;int&gt; a, Span&lt;int&gt; b, Span&lt;int&gt; result)</p>
            <p class="indent-0">{</p>
            <p class="indent-1">if (a.Length + b.Length &gt; result.Length) </p>
            <p class="indent-2">throw new ArgumentException("...");</p>
            <br>
            <p class="indent-1">if (a.Length &lt; b.Length)</p>
            <p class="indent-1">{</p>
            <p class="indent-2">MergeVectorized(b, a, result);</p>
            <p class="indent-2">return;</p>
            <p class="indent-1">}</p>
            <p class="indent-1">var idxA = 0;</p>
            <p class="indent-1">var idxB = 0;</p>
            <p class="indent-1">var idxR = 0;</p>
            <p class="indent-1">var countVec = Vector256&lt;int&gt;.Count;</p>
            <br>
            <p class="indent-1">unsafe</p>
            <p class="indent-1">{</p>
            <p class="indent-2">fixed (int* ptrA = a)</p>
            <p class="indent-2">fixed (int* ptrB = b)</p>
            <p class="indent-2">fixed (int* ptrR = result)</p>
            <p class="indent-2">{</p>
            <p class="indent-3">while ((idxA + countVec) &lt; a.Length && idxB &lt; b.Length)</p>
            <p class="indent-3">{</p>
            <p class="indent-4">// ... see next section ...</p>
            <p class="indent-3">}</p>
            <p class="indent-2">}</p>
            <p class="indent-1">}</p>
            <br>
            <p class="indent-1">MergeScalar(</p>
            <p class="indent-2">a.Slice(idxA),</p>
            <p class="indent-2">b.Slice(idxB),</p>
            <p class="indent-2">result.Slice(idxR),</p>
            <p class="indent-2">...);</p>
            <p class="indent-0">}</p>
        </div>
        <p>Now to the interesting part. We load eight elements from the first argument into a SIMD register and broadcast a single element from the second argument into a second register. As an example, <span class="code-inline">vecA</span> might contain <span class="code-inline">[1, 2, 3, 5, 6, 7, 8, 9]</span> and <span class="code-inline">vecB</span> <span class="code-inline">[4, 4, 4, 4, 4, 4, 4, 4]</span> (<span class="code-inline">4</span> is missing in <span class="code-inline">vecA</span>).</p>
        <p>Compare both lanes, <span class="code-inline">[-1, -1, -1, 0, 0, 0, 0, 0]</span>, and select the elements based on that comparison: <span class="code-inline">[1, 2, 3, 4, 4, 4, 4, 4]</span>. This part is unconditionally written to <span class="code-inline">result</span>.</p>
        <p>The comparison result is then used again to figure out how much work we actually did. <span class="code-inline">vecCmp.ExtractMostSignificantBits()</span> would result in <span class="code-inline">11100000</span> here and <span class="code-inline">PopCount(11100000)</span> in <span class="code-inline">3</span>. <span class="code-inline">incrementB</span> is always one, except when all elements in <span class="code-inline">vecA</span> were less than <span class="code-inline">vecB</span>.</p>
        <div class="code">
            <p class="indent-0">var vecA = Vector256.Load(ptrA + idxA);</p>
            <p class="indent-0">var vecB = Vector256.Create(*(ptrB + idxB));</p>
            <br>
            <p class="indent-0">var vecCmp = Vector256.LessThan(vecA, vecB);</p>
            <p class="indent-0">vecA = Vector256.ConditionalSelect(vecCmp, vecA, vecB);</p>
            <p class="indent-0">vecA.Store(ptrR + idxR);</p>
            <br>
            <p class="indent-0">var cmp = vecCmp.ExtractMostSignificantBits();</p>
            <p class="indent-0">var storeB = BitOperations.PopCount(cmp);</p>
            <p class="indent-0">var incrementB = 1 - (int)(cmp &lt;&lt; 7);</p>
            <br>
            <p class="indent-0">idxA += storeB;</p>
            <p class="indent-0">idxB += incrementB;</p>
            <p class="indent-0">idxR += storeB + incrementB;</p>
        </div>
        <div class="table benchmark">
            <h4>Random sorted integers, .NET 7</h4>
            <p>Method</p><p>n</p><p>Mean</p><p>Error</p><p>StdDev</p><p>Ratio</p>
            <p>Scalar</p><p>262144</p><p>2588.8 us</p><p>4.40 us</p><p>3.90 us</p><p>1.00</p>
            <p>Vector</p><p>262144</p><p>1050.5 us</p><p>4.40 us</p><p>3.90 us</p><p>0.41</p>
        </div>
        <p>Same ratio as the other blog post with a lot less code. They're different compilers, even programming languages but surely the ratio between naive and complex is similar... And doesn't change when we do something small, like an upgrade from .NET 7 to .NET 8. Right?</p>
        <div class="table benchmark">
            <h4>Random sorted integers, .NET 8</h4>
            <p>Method</p><p>n</p><p>Mean</p><p>Error</p><p>StdDev</p><p>Ratio</p>
            <p>Scalar</p><p>262144</p><p>2133.8 us</p><p>1.43 us</p><p>1.27 us</p><p>1.00</p>
            <p>Vector</p><p>262144</p><p>1056.0 us</p><p>0.21 us</p><p>0.18 us</p><p>0.49</p>
        </div>
        <p>The .Net devlopers did their homework. These are the measurments from my desktop machine. My laptop's results are 15% worse because the scalar code allows it to boost higher. Sigh. And the constructed worst case went from tolerable to poor.</p>
        <div class="table benchmark">
            <h4>Last element of A is less than first element of B, .NET 7</h4>
            <p>Method</p><p>n</p><p>Mean</p><p>Error</p><p>StdDev</p><p>Ratio</p>
            <p>Scalar</p><p>262144</p><p>714.5 us</p><p>2.11 us</p><p>1.88 us</p><p>1.00</p>
            <p>Vector</p><p>262144</p><p>148.4 us</p><p>0.15 us</p><p>0.13 us</p><p>0.21</p>
            <p>Vector Reversed</p><p>262144</p><p>1046.7 us</p><p>2.52 us</p><p>2.36 us</p><p>1.47</p>
        </div>
        <div class="table benchmark">
            <h4>Last element of A is less than first element of B, .NET 8</h4>
            <p>Method</p><p>n</p><p>Mean</p><p>Error</p><p>StdDev</p><p>Ratio</p>
            <p>Scalar</p><p>262144</p><p>353.7 us</p><p>0.07 us</p><p>0.07 us</p><p>1.00</p>
            <p>Vector</p><p>262144</p><p>202.2 us</p><p>0.04 us</p><p>0.04 us</p><p>0.57</p>
            <p>Vector Reversed</p><p>262144</p><p>1100.8 us</p><p>0.17 us</p><p>0.15 us</p><p>3.11</p>
        </div>
        <h3>Bitonic Merge</h3>
        <p>Back to the drawing board. I knew that Bitonic sorters were an option but it took me some time to wrap my head around it. At least we can skip half of the algorithm because we're only interested in the merge part.</p>
        <p>My first implementation was 4 times slower than the scalar variant. Bitonic merge takes an ascending and a descending sequence and computes the mininmum/maximum between both. This results in two new sequences where the all elements of the min sequence are less than all elements of the other. This principle is then recursively applied to half of each sequence, until there's nothing left to compare. The algorithm only works with input lengths that are a power of two but many of the comparisons can be done in parallel.</p>
        <p>It took me some time until I realized that the first Iteration uses <span class="code-inline">Vector256</span> and every following only <span class="code-inline">Vector128</span> for comparisons. We also don't need <span class="code-inline">Vector256.Max(vecA, vecB)</span>, because it gets discarded anyway, and that <span class="code-inline">Vector256.Min(vecA, vecB)</span> encodes how many elements of <span class="code-inline">a</span> and <span class="code-inline">b</span> get stored in the final result. At some point it just clicked and everything fell into place but not until I almost gave up. Don't make my mistake and start with unit tests for every single shuffle, if you want to try it yourself.</p>
        <div class="code">
            <p class="indent-0">var vecA = Load(ptrA + idxA);</p>
            <p class="indent-0">var vecB = Load(ptrB + idxB);</p>
            <p class="indent-0">var copyVecA = vecA;</p>
            <p class="indent-0">vecB = Shuffle(vecB, Create(7, 6, 5, 4, 3, 2, 1, 0));</p>
            <br>
            <p class="indent-0">vecA = Min(vecA, vecB);</p>
            <p class="indent-0">var incrementA = BitOperations.PopCount(</p>
            <p class="indent-1">    Equals&lt;int&gt;(vecA, copyVecA).ExtractMostSignificantBits());</p>
            <p class="indent-0">vecA = CompareAndSwap128(vecA);</p>
            <p class="indent-0">vecA = Shuffle(vecA, Create(0, 1, 4, 5, 2, 3, 6, 7));</p>
            <p class="indent-0">vecA = CompareAndSwap128(vecA);</p>
            <p class="indent-0">vecA = Shuffle(vecA, Create(0, 2, 4, 6, 1, 3, 5, 7));</p>
            <p class="indent-0">vecA = CompareAndSwap128(vecA);</p>
            <p class="indent-0">vecA = Shuffle(vecA, Create(0, 4, 2, 6, 1, 5, 3, 7));</p>
            <br>
            <p class="indent-0">vecA.Store(ptrR + idxR);</p>
            <br>
            <p class="indent-0">idxA += incrementA;</p>
            <p class="indent-0">idxB += countVec - incrementA;</p>
            <p class="indent-0">idxR += countVec;</p>
        </div>
        <div class="code">
            <p class="indent-0">[MethodImpl(MethodImplOptions.AggressiveInlining)]</p>
            <p class="indent-0">public static Vector256&lt;int&gt; CompareAndSwap128(Vector256&lt;int&gt; vec)</p>
            <p class="indent-0">{</p>
            <p class="indent-1">var lower = Vector128.Min(vec.GetLower(), vec.GetUpper());</p>
            <p class="indent-1">var upper = Vector128.Max(vec.GetLower(), vec.GetUpper());</p>
            <br>
            <p class="indent-1">return Create(lower, upper);</p>
            <p class="indent-0">}</p>
        </div>

        <h3>Final Benchmarks</h3>

        <div class="table benchmark">
            <h4>Random sorted integers</h4>
            <p>Method</p><p>n</p><p>Mean</p><p>Error</p><p>StdDev</p><p>Ratio</p>
            <p>Scalar</p><p>262144</p><p>2133.8 us</p><p>1.43 us</p><p>1.27 us</p><p>1.00</p>
            <p>Vector</p><p>262144</p><p>1056.0 us</p><p>0.21 us</p><p>0.18 us</p><p>0.49</p>
            <p>Bitonic</p><p>262144</p><p>412.3 us</p><p>0.35 us</p><p>0.29 us</p><p>0.19</p>
        </div>
        <div class="table benchmark">
            <h4>Same input</h4>
            <p>Method</p><p>n</p>       <p>Mean</p>         <p>Error</p>    <p>StdDev</p>   <p>Ratio</p>
            <p>Scalar</p><p>262144</p>  <p>1148.3 us</p>   <p>0.58 us</p>  <p>0.51 us</p>  <p>1.00</p>
            <p>Vector</p><p>262144</p>  <p>1046.6 us</p>   <p>0.30 us</p>  <p>0.26 us</p>  <p>0.91</p>
            <p>Bitonic</p><p>262144</p> <p>403.4 us</p>     <p>0.14 us</p>  <p>0.16 us</p>  <p>0.35</p>
        </div>
        <div class="table benchmark">
            <h4>Second Argument is tiny (8 elements)</h4>
            <p>Method</p><p>n</p>       <p>Mean</p>        <p>Error</p>    <p>StdDev</p>   <p>Ratio</p>
            <p>Scalar</p><p>262144</p>  <p>396.28 us</p>   <p>0.56 us</p>  <p>0.50 us</p>  <p>1.00</p>
            <p>Vector</p><p>262144</p>  <p>144.36 us</p>   <p>0.05 us</p>  <p>0.04 us</p>  <p>0.36</p>
            <p>Bitonic</p><p>262144</p> <p>148.09 us</p>   <p>0.04 us</p>  <p>0.04 us</p>  <p>0.37</p>
            <p>Binary Search</p><p>262144</p>  <p>19.03 us</p>    <p>0.04 us</p>  <p>0.03 us</p>  <p>0.05</p>
        </div>
        <div class="table benchmark">
            <h4>Alternating stair steps</h4>
            <p>Method</p><p>n</p>       <p>Mean</p>        <p>Error</p>    <p>StdDev</p>   <p>Ratio</p>
            <p>Scalar</p><p>262144</p>  <p>1217.7 us</p>   <p>0.19 us</p>  <p>0.18 us</p>  <p>1.00</p>
            <p>Vector</p><p>262144</p>  <p>1015.7 us</p>   <p>0.32 us</p>  <p>0.28 us</p>  <p>0.83</p>
            <p>Bitonic</p><p>262144</p> <p>393.3 us</p>    <p>0.08 us</p>  <p>0.07 us</p>  <p>0.32</p>
        </div>
        <div class="table benchmark">
            <h4>Concatenated (last element of A is less than first of B)</h4>
            <p>Method</p><p>n</p>       <p>Mean</p>      <p>Error</p>    <p>StdDev</p>   <p>Ratio</p>
            <p>Scalar</p><p>262144</p>  <p>353.7 us</p>  <p>0.07 us</p>  <p>0.07 us</p>  <p>1.00</p>
            <p>Vector</p><p>262144</p>  <p>202.2 us</p>  <p>0.04 us</p>  <p>0.03 us</p>  <p>0.57</p>
            <p>Bitonic</p><p>262144</p> <p>267.9 us</p>  <p>0.13 us</p>  <p>0.13 us</p>  <p>0.76</p>
            <p>Vector Reversed</p><p>262144</p>  <p>1100.8 us</p>   <p>0.17 us</p>  <p>0.15 us</p>  <p>3.11</p>
        </div>
        <h3>Conclusion</h3>
        <p>About a third of the scalar's execution time and better than the first attempt in almost every way. Neat, I'm going to leave it like that. Although I'm happy with the results, there are probably still a few unoptimized spots left and different algorithms to explore. Batchers's Odd-Even Merge (Sort) and <a href="https://inria.hal.science/hal-01512970v1/document">AVX-512 support</a> come to mind.</p>
    </div>

    <div class="textarea" id="taming-d3">
        <h2>Making D3 readable</h2>
        <p>Over the last few years I worked with multiple projects that used Data Driven Documents, also known as D3.js or just D3. While I think it's one of the best charting libraries out there, especially if you don't know all of your requirements yet, the resulting code can be furstratingly difficult to maintain. It's very much write once and pray that you don't ever have to update it. This shouldn't be the case and recently I really tried to get it right. These are my biggest takeaways.</p>
        <h3>Refactor early and often</h3>
        <p>Your first draft shouldn't be your last. Tell your higher ups that this is a proof of concept which needs revision after it's done, especially if it is your first time with D3. If you can't do that, use a different library.</p>
        <h3>Use layers</h3>
        <p>You will run into rendering issues when SVG elemens overlap. Tooltips should be drawn on top of everything else, bars over axes, lines below connecting points. Stuff like that. You can either make sure to always get the order of operations right or you can use a layer system, similar to what you find in image manipulation programs.</p>
        <div class="code">
            <p class="indent-0">function appendLayer(targetSvg, layerName) &lbrace;</p>
            <p class="indent-1">return targetSvg.append('g').attr('id', layerName);</p>
            <p class="indent-0">&rbrace;</p>
            <br>
            <p class="indent-0">function selectLayer(sourceSvg, layerName) &lbrace;</p>
            <p class="indent-1">return sourceSvg.select(`#${layerName}`);</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <div class="code">
            <p class="indent-0">function createSvgTemplate(...) &lbrace;</p>
            <p class="indent-1">// ... initialization ...</p>
            <br>
            <p class="indent-1">appendLayer(svg, 'background');</p>
            <p class="indent-1">appendLayer(svg, 'plot_0');</p>
            <p class="indent-1">appendLayer(svg, 'plot_1');</p>
            <p class="indent-1">appendLayer(svg, 'plot_2');</p>
            <p class="indent-1">appendLayer(svg, 'headline');</p>
            <p class="indent-1">appendLayer(svg, 'tooltip');</p>
            <br>
            <p class="indent-1">// ... returns ...</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <h3>Turn D3 into D1</h3>
        <p>This one took me way too long to realize. Every modern web framework tries to solve two things: state management and data binding. D3 can do both, it's called Data Driven Documents after all, but stop for a second and ask yourself: should you use these features? Your entire team is accustomed to a certain style and now you introduce a new way of doing things. One that's probably worse than what you're already using. The only thing you really care about in the end is an SVG Document. So do yourself a favor and ignore the Data Driven part.</p>
        <p>If you don't, one issue you will almost definitely run into is the good old <span class="code-inline">undefined</span>. If such a value infects your data, it gets turned into <span class="code-inline">NaN</span> and your SVG will break. It's just that sometimes your really want to signal the absence of something, like in line graphs. You can't just replace <span class="code-inline">undefined</span> with <span class="code-inline">0</span>, a line with incomplete data should be broken up into multiple pieces. It's one of the things you have to handle outside of D3's fluent interface. Now you're mixing application logic with D3 logic.</p>
        <p>Just draw the stuff you want to draw in a loop, piece by piece, and assign a unique id to each element. If you need to update stuff, query it by id. Delete it? Query by id. Yes, this does mean that you may have to diff your current state with the previous one but it's a small price to pay.</p>
        <h3>Focus on primitives</h3>
        <p>For a long time I used to separate my functions into steps that made sense from a business perspective, like <span class="code-inline">initLineGraph</span>, <span class="code-inline">initBarGraph</span>, <span class="code-inline">updateBarGraph</span> etc. but this falls apart with reasonably complicated requirements. Does a new element belong to the initialization function or is it an update? What about deletes? How do I even detect elements ready to be deleted? A better way to do things, even if it sounds worse at first, is to have one function per primitive that does everything:</p>
        <div class="code">
            <p class="indent-0">function isPoison(nbr) &lbrace;</p>
            <p class="indent-1">return nbr == null || isNaN(nbr) || !isFinite(nbr);</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <div class="code">
            <p class="indent-0">function updatePoint(target, index, coordinates, metadata) &lbrace;</p>
            <p class="indent-1">const id = `${metadata.id}_${index}`;</p>
            <p class="indent-1">let selection = selectLayer(target, metadata.layerName)</p>
            <p class="indent-2">.select(`circle#${id}`);</p>
            <p class="indent-1">const x = coordinates.x(index);</p>
            <p class="indent-1">const y = coordinates.y(index);</p>
            <br>
            <p class="indent-1">const poison = isPoison(x) || isPoison(y);</p>
            <p class="indent-1">if (poison && selection.empty()) return;</p>
            <p class="indent-1">if (poison) &lbrace;</p>
            <p class="indent-2">selection.remove();</p>
            <p class="indent-2">return;</p>
            <p class="indent-1">&rbrace;</p>
            <br>
            <p class="indent-1">if (selection.empty()) &lbrace;</p>
            <p class="indent-2">selection = selectLayer(target, metadata.layerName)</p>
            <p class="indent-3">.append('circle')</p>
            <p class="indent-3">.attr('id', id)</p>
            <p class="indent-3">.attr('r', 3);</p>
            <p class="indent-2">// more customization</p>
            <p class="indent-1">&rbrace;</p>
            <br>
            <p class="indent-1">selection</p>
            <p class="indent-2">.transition()</p>
            <p class="indent-2">.duration(500)</p>
            <p class="indent-2">.attr('cx', x)</p>
            <p class="indent-2">.attr('cy', y);</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>This is reasonably short, robust, reusable and completely independent of your business requirements. Note that I'm using an <span class="code-inline">index</span> and <span class="code-inline">x</span>/<span class="code-inline">y</span> accessor functions instead of actual data. This not only decouples the interface from the implementation, it also makes your primitive functions more similar: <span class="code-inline">updateLine</span> would use <span class="code-inline">x(index - 1)</span> in addition to <span class="code-inline">x(index)</span> and while an <span class="code-inline">updateRectangle</span> function needs two more accessors to actually make a rectangle, they can just be an extension of your <span class="code-inline">Coordinate</span> interface.</p>
        <p>Sidenote, if you're having trouble to make a correct <span class="code-inline">rect</span> in combination with D3's scaling functions, use a <span class="code-inline">polygon</span> instead.</p>
        <h3>Unsolved issues</h3>
        <p>Interactive features, such as hover effects. I'm getting there but so far no solution felt completely "clean". Like everything else, it's appealing to put events into your initialization block, next to all the other style settings but now your update function is taking callbacks that you sometimes do and sometimes don't need. The exact function that already handles init, update and delete. I don't like it.</p>
        <h3>Future improvements</h3>
        <p>So far I didn't have the time or opportunity to implement them but I think projection matrices would be a great addition. As an example, consider the data point <span class="code-inline">(1, 1_000_000)</span>. Your SVG is probably not 1 million units high and D3 has different scaling functions to make sure the point is displayed adequately. The scaled plot is then scaled again because you don't want to just display your data points. Headlines, axes and the legend all need space, too.</p>
        <p>Assuming the scale range is linear, this could be done much more elegantly with two matrix multiplications. One to scale your data into <span class="code-inline">(-1, -1), (1, 1)</span> space and one to scale it to parts of the SVG container, e.g. to <span class="code-inline">(350, 590), (50, 50)</span>. When the mouse pointer hovers over a chart element, a ray cast would be enough to trace all the way from the affected SVG container in the dom back to the source data that was used to draw a specific element. It could handle click, enter, move and exit events all in one go. You could also discard (almost) everything that's not in the range of <span class="code-inline">(-1, 1)</span> before you do your update and now you have the math to make it work with <span class="code-inline">canvas</span> and <span class="code-inline">WebGPU</span>, too.</p>
        <p>I'm not sure about what's left of D3 after this. Maybe it's time for a new library...</p>
    </div>

    <div class="textarea" id="vectorization-net-7">
        <h2>Vectorization has come a long way in .NET</h2>
        <p class="italic smaller">Disclaimer: I wrote this blog post originally for my employer's website, Tekaris. The website does no longer exist to my knowledge.</p>
        <br>
        <p>Vectorization, or Single Instruction Multiple Data (SIMD), is the art of performing the same operation simultaneously on a small block of different pieces of data. While many compilers do support some kind of auto-vectorization, it's often fragile and even small changes can break everything. But SIMD code written by hand is difficult to read and has to be implemented multiple times for multiple platforms, with fallbacks if the customer's CPU doesn't support it.</p>
        <br>
        <p>Over the Christmas holidays I had the chance to revisit and port a personal project from .NET 6 to .NET 7 and gave vectorization a second look. I don't think the above statement is 100% true anymore. In some way, it turned out to be the opposite. Let me give you an example, a <span class="code-inline">Color</span> struct with two methods: <span class="code-inline">Equals</span> as an example for an operator and <span class="code-inline">AlphaBlend</span>, which is a simple textbook implementation of layering two pixels on top of each other.</p>
        <div class="code">
            <p class="indent-0">[StructLayout(LayoutKind.Sequential)]</p>
            <p class="indent-0">public readonly struct Color</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">public float A { get; }</p>
            <p class="indent-1">public float R { get; }</p>
            <p class="indent-1">public float G { get; }</p>
            <p class="indent-1">public float B { get; }</p>
            <br>
            <p class="indent-1">public Color AlphaBlend(Color top) => new&lpar;</p>
            <p class="indent-2">top.A + A * &lpar;1 - top.A&rpar;,</p>
            <p class="indent-2">top.R + R * &lpar;1 - top.A&rpar;,</p>
            <p class="indent-2">top.G + G * &lpar;1 - top.A&rpar;,</p>
            <p class="indent-2">top.B + B * &lpar;1 - top.A&rpar;&rpar;;</p>
            <br>
            <p class="indent-1">public bool Equals(Color other) =></p>
            <p class="indent-2">A == other.A</p>
            <p class="indent-2">&& R == other.R</p>
            <p class="indent-2">&& G == other.G</p>
            <p class="indent-2">&& B == other.B;</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>While both methods are four lines long, the actual logic is only one line, repeated four times. As the name suggests, Single Instruction Multiple Data is meant for these kinds of tasks.</p>
        <h3>C#'s Vector in the past</h3>
        <p>C# provides four different types that help us with vectorization: <span class="code-inline">Vector64&lt;T&gt;</span>, <span class="code-inline">Vector128&lt;T&gt;</span>, <span class="code-inline">Vector256&lt;T&gt;</span> and <span class="code-inline">Vector&lt;T&gt;</span>. <span class="code-inline">Vector&lt;T&gt;</span> has an unspecified size and will use one of the other three types internally. The others are fixed size, as their name suggests, but can be split in different ways. One <span class="code-inline">Vector128</span> can hold two 64 bit <span class="code-inline">long</span>, four 32 bit <span class="code-inline">int</span> or eight 16 bit <span class="code-inline">short</span>. Floating point numbers are supported as well but custom structs will fail at runtime.</p>
        <p>I did implement a vectorized version of <span class="code-inline">AlphaBlend</span> prior to C# 11 for performance and curiosity. It wasn't pretty. <span class="code-inline">Color</span> is a struct of four 32 bit <span class="code-inline">float</span>s, which is 128 bit in total, the same size as <span class="code-inline">Vector128&lt;float&gt;</span>. To perform operations on a <span class="code-inline">Vector128</span>, you had to use the functions defined in the <span class="code-inline">Sse</span>/<span class="code-inline">Avx</span> static classes. These will fail at runtime if the host's CPU doesn't support them and it's up to you to cover the possibility.</p>
        <div class="code">
            <p class="indent-0">public Vector128&lt;float&gt; Vec128 =></p>
            <p class="indent-1">Unsafe.As&lt;ColorF32, Vector128&lt;float&gt;&gt;(ref Unsafe.AsRef(in this));</p>
            <br>
            <p class="indent-0">public Color AlphaBlend(Color top)</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">if (Sse.IsSupported)</p>
            <p class="indent-1">&lbrace;</p>
            <p class="indent-2">var vResult = Sse.Multiply(Vec128, Vector128.Create(1.0f - top.A));</p>
            <p class="indent-2">vResult = Sse.Add(vResult, top.Vec128);</p>
            <p class="indent-2">return new(vResult);</p>
            <p class="indent-1">&rbrace;</p>
            <p class="indent-1">else</p>
            <p class="indent-1">&lbrace;</p>
            <p class="indent-2">return new&lpar;</p>
            <p class="indent-3">a: top.A + A * (1 - top.A),</p>
            <p class="indent-3">r: top.R + R * (1 - top.A),</p>
            <p class="indent-3">g: top.G + G * (1 - top.A),</p>
            <p class="indent-3">b: top.B + B * (1 - top.A)&rpar;;</p>
            <p class="indent-1">&rbrace;</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>Are those unsafe casts safe? The unit tests pass but I'm not sure I would risk it in production. It doesn't support ARM CPUs and looks a lot scarier in languages that only provide cryptic names or have to fall back to metaprogramming to eliminate the if-else branch. At least C#'s JIT is smart enough to detect such simple patterns at runtime and rewrite the function without branches (depending on what the host's CPU supports).</p>
        <h3>C# 11's Vector</h3>
        <p>With C# 11 you don't have to write the code above anymore because the <span class="code-inline">Vector</span> classes have their own operators and utility functions now! It's a small change that has a massive impact on readability and maintainability. The vectorized version is now on par with the scalar version in terms of readability, and even a little shorter. Since it was so easy to make the entire class vectorized, I also changed the ARGB values to be of type <span class="code-inline">Vector128&lt;float&gt;</span> internally and provide getters instead, which yielded additional performance improvements. The <span class="code-inline">Unsafe</span> methods seem to not be zero cost like I thought initially. Generic Math (also new in C# 11, not shown here) was a breeze to implement.</p>
        <div class="code">
            <p class="indent-0">public readonly struct Color</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">private readonly Vector128&lt;float&gt; argb;</p>
            <br>
            <p class="indent-1">public Vector128&lt;float&gt; Vector => argb;</p>
            <br>
            <p class="indent-1">public float A => argb.GetElement(0);</p>
            <p class="indent-1">public float R => argb.GetElement(1);</p>
            <p class="indent-1">public float G => argb.GetElement(2);</p>
            <p class="indent-1">public float B => argb.GetElement(3);</p>
            <br>
            <p class="indent-1">public Color AlphaBlend(Color top) =></p>
            <p class="indent-2">new(Vector * Vector128.Create(1.0f - top.A) + top.Vector);</p>
            <br>
            <p class="indent-1">public bool Equals(Color other) => Vector == other.Vector;</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>Are there still functions that cannot be implemented this way? Would it be even faster to <span class="code-inline">MemoryMarshal.Cast</span> an array of colors to a <span class="code-inline">Vector256&lt;float&gt;</span>? Of course. But the next time you write a simple container of homogenous data, stop and think for a second if you could express it as a <span class="code-inline">Vector</span> internally. Maybe someone will thank you for your extra care someday, or at least learn something new while looking through your source code.</p>
    </div>

    <div class="textarea" id="haskell-io">
        <h2>Haskell was right</h2>
        <p>It's somewhat ironic that many programmers think that the (IO) monad is overly complicated and solves problems that could only ever exist in a pure lazy functional programming language; Yet, at the same time, are convinced that the following code should be considered good practice:</p>
        <div class="code">
            <p class="indent-0">public interface IProcessor</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">async Task<...> ProcessData(int id);</p>
            <p class="indent-0">&rbrace;</p>
            <br/>
            <p class="indent-0">public class Processor : IProcessor</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">private readonly IDbConnector dbConnector;</p>
            <br/>
            <p class="indent-1">public async Task<...> ProcessData(int id)</p>
            <p class="indent-1">&lbrace;</p>
            <p class="indent-2">var data = await dbConnector.QueryAsync(id);</p>
            <p class="indent-2">return TransformData(data);</p>
            <p class="indent-1">&rbrace;</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>... where IO is explicitly marked in three different places.</p>
        <p>- <span class="code-inline">async</span> because you do not want your app to lag or your web server run out of threads. There are very few cases where <span class="code-inline">async</span> does not imply IO.</p>
        <p>- <span class="code-inline">IDbConnector</span> because you might want to mock IO away for testing. Or use a different database later on... because that always works without breaking changes...</p>
        <p>- <span class="code-inline">IProcessor</span> because Dependency Injection is the best thing since sliced bread and correctly mocking a database connector is hard.</p>
        <br>
        <p>Of course, all of this is less general than monads and you will be changing the <span class="code-inline">IProcessor</span> interface every time you add or remove a method from<span class="code-inline">Processor</span>. This code is not and never was about composability or API stability, it's a mess of bandaids for the underlying problems that come with IO. You just accepted it as "clean code" because everyone else does the same thing.</p>
        <p>Academia has good reasons for handling things in a certain way and we should build on their foundations, not ignore them.</p>
    </div>
    
    <div class="textarea" id="about-me">
        <h2>About</h2>
        <p>Hi! I'm Philipp, a software developer based in Munich, Germany. While my daily work is mostly full stack development, my interests reach far beyond that, including programming language research, low level optimizations and game engines. Outside of computer science there's also painting and photography, which are huge hobbies, too.</p>
    </div>
  </body>
</html>
