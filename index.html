<!doctype html>
<html lang="en-US">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="A blog about various topics related to programming and art. Author: Philipp Schmid; Functional Programming, SIMD, Vectorization, Digital Painting, CSharp, C#">
    <meta name="theme-color" content="#16433d"/>
    <link rel="stylesheet" href="default-reset.css">
    <link rel="stylesheet" href="default-styles.css">
    <link rel="stylesheet" href="default-header.css">
    <link rel="stylesheet" href="default-code.css">
    <link rel="stylesheet" href="media-highres.css">
    <link rel="stylesheet" href="media-mobile.css">
    <link rel="stylesheet" href="media-sidenav.css">
    <title>Cooked Cthulhu's Blog</title>
  </head>
  <body>
        <div class="header-nonsticky"></div>
        <div class="header">
        <div class="sidenav code">
            <div><a href="#taming-d3">Making D3 readable</a></div>
            <div><a href="#vectorization-net-7">Vectorization in .NET 7</a></div>
            <div><a href="#haskell-io">Haskell was right</a></div>
            <div><a href="#about-me">About</a></div>
        </div>
        <div><h3>Home</h1></div>
        <svg preserveAspectRatio="none" viewBox="0 0 100 30">
            <path fill="#16433d" d="
                m-20, 10
                c 10, 0 5, 13 13, 13
                c 10, 0 12, -10 24, -10
                c 10, 0 12,  10 24, 10
                c 10, 0 12, -10 24, -10
                c 10, 0 12,  10 24, 10
                c 10, 0 12, -10 24, 0
                L 100 0
                L 0 0">
            </path>
        </svg>
    </div>
    <div class="header-shadow"></div>

    <div class="textarea" id="taming-d3">
        <h2>Making D3 readable</h2>
        <p>Over the last few years I worked with multiple projects that used Data Driven Documents, also known as D3.js or just D3. While I think it's one of the best charting libraries out there, especially if you don't know all of your requirements yet, the resulting code can be furstratingly difficult to maintain. It's very much write once and pray that you don't ever have to update it. This shouldn't be the case and recently I really tried to get it right. These are my biggest takeaways.</p>
        <h3>Refactor early and often</h3>
        <p>Your first draft shouldn't be your last. Tell your higher ups that this is a proof of concept which needs revision after it's done, especially if it is your first time with D3. If you can't do that, use a different library.</p>
        <h3>Use layers</h3>
        <p>You will run into rendering issues when SVG elemens overlap. Tooltips should be drawn on top of everything else, bars over axes, lines below connecting points. Stuff like that. You can either make sure to always get the order of operations right or you can use a layer system, similar to what you find in image manipulation programs.</p>
        <div class="code">
            <p class="indent-0">function appendLayer(targetSvg, layerName) &lbrace;</p>
            <p class="indent-1">return targetSvg.append('g').attr('id', layerName);</p>
            <p class="indent-0">&rbrace;</p>
            <br>
            <p class="indent-0">function selectLayer(sourceSvg, layerName) &lbrace;</p>
            <p class="indent-1">return sourceSvg.select(`#${layerName}`);</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <div class="code">
            <p class="indent-0">function createSvgTemplate(...) &lbrace;</p>
            <p class="indent-1">// ... initialization ...</p>
            <br>
            <p class="indent-1">appendLayer(svg, 'background');</p>
            <p class="indent-1">appendLayer(svg, 'plot_0');</p>
            <p class="indent-1">appendLayer(svg, 'plot_1');</p>
            <p class="indent-1">appendLayer(svg, 'plot_2');</p>
            <p class="indent-1">appendLayer(svg, 'headline');</p>
            <p class="indent-1">appendLayer(svg, 'tooltip');</p>
            <br>
            <p class="indent-1">// ... returns ...</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <h3>Turn D3 into D1</h3>
        <p>This one took me way too long to realize. Every modern web framework tries to solve two things: state management and data binding. D3 can do both, it's called Data Driven Documents after all, but stop for a second and ask yourself: should you use these features? Your entire team is accustomed to a certain style and now you introduce a new way of doing things. One that's probably worse than what you're already using. The only thing you really care about in the end is an SVG Document. So do yourself a favor and ignore the Data Driven part.</p>
        <p>If you don't, one issue you will almost definitely run into is the good old <span class="code-inline">undefined</span>. If such a value infects your data, it gets turned into <span class="code-inline">NaN</span> and your SVG will break. It's just that sometimes your really want to signal the absence of something, like in line graphs. You can't just replace <span class="code-inline">undefined</span> with <span class="code-inline">0</span>, a line with incomplete data should be broken up into multiple pieces. It's one of the things you have to handle outside of D3's fluent interface. Now you're mixing application logic with D3 logic.</p>
        <p>Just draw the stuff you want to draw in a loop, piece by piece, and assign a unique id to each element. If you need to update stuff, query it by id. Delete it? Query by id. Yes, this does mean that you may have to diff your current state with the previous one but it's a small price to pay.</p>
        <h3>Focus on primitives</h3>
        <p>For a long time I used to separate my functions into steps that made sense from a business perspective, like <span class="code-inline">initLineGraph</span>, <span class="code-inline">initBarGraph</span>, <span class="code-inline">updateBarGraph</span> etc. but this falls apart with reasonably complicated requirements. Does a new element belong to the initialization function or is it an update? What about deletes? How do I even detect elements ready to be deleted? A better way to do things, even if it sounds worse at first, is to have one function per primitive that does everything:</p>
        <div class="code">
            <p class="indent-0">function isPoison(nbr) &lbrace;</p>
            <p class="indent-1">return nbr == null || isNaN(nbr) || !isFinite(nbr);</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <div class="code">
            <p class="indent-0">function updatePoint(target, index, coordinates, metadata) &lbrace;</p>
            <p class="indent-1">const id = `${metadata.id}_${index}`;</p>
            <p class="indent-1">let selection = selectLayer(target, metadata.layerName)</p>
            <p class="indent-2">.select(`circle#${id}`);</p>
            <p class="indent-1">const x = coordinates.x(index);</p>
            <p class="indent-1">const y = coordinates.y(index);</p>
            <br>
            <p class="indent-1">const poison = isPoison(x) || isPoison(y);</p>
            <p class="indent-1">if (poison && selection.empty()) return;</p>
            <p class="indent-1">if (poison) &lbrace;</p>
            <p class="indent-2">selection.remove();</p>
            <p class="indent-2">return;</p>
            <p class="indent-1">&rbrace;</p>
            <br>
            <p class="indent-1">if (selection.empty()) &lbrace;</p>
            <p class="indent-2">selection = selectLayer(target, metadata.layerName)</p>
            <p class="indent-3">.append('circle')</p>
            <p class="indent-3">.attr('id', id)</p>
            <p class="indent-3">.attr('r', 3);</p>
            <p class="indent-2">// more customization</p>
            <p class="indent-1">&rbrace;</p>
            <br>
            <p class="indent-1">selection</p>
            <p class="indent-2">.transition()</p>
            <p class="indent-2">.duration(500)</p>
            <p class="indent-2">.attr('cx', x)</p>
            <p class="indent-2">.attr('cy', y);</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>This is reasonably short, robust, reusable and completely independent of your business requirements. Note that I'm using an <span class="code-inline">index</span> and <span class="code-inline">x</span>/<span class="code-inline">y</span> accessor functions instead of actual data. This not only decouples the interface from the implementation, it also makes your primitive functions more similar: <span class="code-inline">updateLine</span> would use <span class="code-inline">x(index - 1)</span> in addition to <span class="code-inline">x(index)</span> and while an <span class="code-inline">updateRectangle</span> function needs two more accessors to actually make a rectangle, they can just be an extension of your <span class="code-inline">Coordinate</span> interface.</p>
        <p>Sidenote, if you're having trouble to make a correct <span class="code-inline">rect</span> in combination with D3's scaling functions, use a <span class="code-inline">polygon</span> instead.</p>
        <h3>Unsolved issues</h3>
        <p>Interactive features, such as hover effects. I'm getting there but so far no solution felt completely "clean". Like everything else, it's appealing to put events into your initialization block, next to all the other style settings but now your update function is taking callbacks that you sometimes do and sometimes don't need. The exact function that already handles init, update and delete. I don't like it.</p>
        <h3>Future improvements</h3>
        <p>So far I didn't have the time or opportunity to implement them but I think projection matrices would be a great addition. As an example, consider the data point <span class="code-inline">(1, 1_000_000)</span>. Your SVG is probably not 1 million units high and D3 has different scaling functions to make sure the point is displayed adequately. The scaled plot is then scaled again because you don't want to just display your data points. Headlines, axes and the legend all need space, too.</p>
        <p>Assuming the scale range is linear, this could be done much more elegantly with two matrix multiplications. One to scale your data into <span class="code-inline">(-1, -1), (1, 1)</span> space and one to scale it to parts of the SVG container, e.g. to <span class="code-inline">(350, 590), (50, 50)</span>. When the mouse pointer hovers over a chart element, a ray cast would be enough to trace all the way from the affected SVG container in the dom back to the source data that was used to draw a specific element. It could handle click, enter, move and exit events all in one go. You could also discard (almost) everything that's not in the range of <span class="code-inline">(-1, 1)</span> before you do your update and now you have the math to make it work with <span class="code-inline">canvas</span> and <span class="code-inline">WebGPU</span>, too.</p>
        <p>I'm not sure about what's left of D3 after this. Maybe it's time for a new library...</p>
    </div>

    <div class="textarea" id="vectorization-net-7">
        <h2>Vectorization has come a long way in .NET</h2>
        <p class="italic smaller">Disclaimer: I wrote this blog post originally for my employer's website, Tekaris. The website does no longer exist to my knowledge.</p>
        <br>
        <p>Vectorization, or Single Instruction Multiple Data (SIMD), is the art of performing the same operation simultaneously on a small block of different pieces of data. While many compilers do support some kind of auto-vectorization, it's often fragile and even small changes can break everything. But SIMD code written by hand is difficult to read and has to be implemented multiple times for multiple platforms, with fallbacks if the customer's CPU doesn't support it.</p>
        <br>
        <p>Over the Christmas holidays I had the chance to revisit and port a personal project from .NET 6 to .NET 7 and gave vectorization a second look. I don't think the above statement is 100% true anymore. In some way, it turned out to be the opposite. Let me give you an example, a <span class="code-inline">Color</span> struct with two methods: <span class="code-inline">Equals</span> as an example for an operator and <span class="code-inline">AlphaBlend</span>, which is a simple textbook implementation of layering two pixels on top of each other.</p>
        <div class="code">
            <p class="indent-0">[StructLayout(LayoutKind.Sequential)]</p>
            <p class="indent-0">public readonly struct Color</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">public float A { get; }</p>
            <p class="indent-1">public float R { get; }</p>
            <p class="indent-1">public float G { get; }</p>
            <p class="indent-1">public float B { get; }</p>
            <br>
            <p class="indent-1">public Color AlphaBlend(Color top) => new&lpar;</p>
            <p class="indent-2">top.A + A * &lpar;1 - top.A&rpar;,</p>
            <p class="indent-2">top.R + R * &lpar;1 - top.A&rpar;,</p>
            <p class="indent-2">top.G + G * &lpar;1 - top.A&rpar;,</p>
            <p class="indent-2">top.B + B * &lpar;1 - top.A&rpar;&rpar;;</p>
            <br>
            <p class="indent-1">public bool Equals(Color other) =></p>
            <p class="indent-2">A == other.A</p>
            <p class="indent-2">&& R == other.R</p>
            <p class="indent-2">&& G == other.G</p>
            <p class="indent-2">&& B == other.B;</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>While both methods are four lines long, the actual logic is only one line, repeated four times. As the name suggests, Single Instruction Multiple Data is meant for these kinds of tasks.</p>
        <h3>C#'s Vector in the past</h3>
        <p>C# provides four different types that help us with vectorization: <span class="code-inline">Vector64&lt;T&gt;</span>, <span class="code-inline">Vector128&lt;T&gt;</span>, <span class="code-inline">Vector256&lt;T&gt;</span> and <span class="code-inline">Vector&lt;T&gt;</span>. <span class="code-inline">Vector&lt;T&gt;</span> has an unspecified size and will use one of the other three types internally. The others are fixed size, as their name suggests, but can be split in different ways. One <span class="code-inline">Vector128</span> can hold two 64 bit <span class="code-inline">long</span>, four 32 bit <span class="code-inline">int</span> or eight 16 bit <span class="code-inline">short</span>. Floating point numbers are supported as well but custom structs will fail at runtime.</p>
        <p>I did implement a vectorized version of <span class="code-inline">AlphaBlend</span> prior to C# 11 for performance and curiosity. It wasn't pretty. <span class="code-inline">Color</span> is a struct of four 32 bit <span class="code-inline">float</span>s, which is 128 bit in total, the same size as <span class="code-inline">Vector128&lt;float&gt;</span>. To perform operations on a <span class="code-inline">Vector128</span>, you had to use the functions defined in the <span class="code-inline">Sse</span>/<span class="code-inline">Avx</span> static classes. These will fail at runtime if the host's CPU doesn't support them and it's up to you to cover the possibility.</p>
        <div class="code">
            <p class="indent-0">public Vector128&lt;float&gt; Vec128 =></p>
            <p class="indent-1">Unsafe.As&lt;ColorF32, Vector128&lt;float&gt;&gt;(ref Unsafe.AsRef(in this));</p>
            <br>
            <p class="indent-0">public Color AlphaBlend(Color top)</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">if (Sse.IsSupported)</p>
            <p class="indent-1">&lbrace;</p>
            <p class="indent-2">var vResult = Sse.Multiply(Vec128, Vector128.Create(1.0f - top.A));</p>
            <p class="indent-2">vResult = Sse.Add(vResult, top.Vec128);</p>
            <p class="indent-2">return new(vResult);</p>
            <p class="indent-1">&rbrace;</p>
            <p class="indent-1">else</p>
            <p class="indent-1">&lbrace;</p>
            <p class="indent-2">return new&lpar;</p>
            <p class="indent-3">a: top.A + A * (1 - top.A),</p>
            <p class="indent-3">r: top.R + R * (1 - top.A),</p>
            <p class="indent-3">g: top.G + G * (1 - top.A),</p>
            <p class="indent-3">b: top.B + B * (1 - top.A)&rpar;;</p>
            <p class="indent-1">&rbrace;</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>Are those unsafe casts safe? The unit tests pass but I'm not sure I would risk it in production. It doesn't support ARM CPUs and looks a lot scarier in languages that only provide cryptic names or have to fall back to metaprogramming to eliminate the if-else branch. At least C#'s JIT is smart enough to detect such simple patterns at runtime and rewrite the function without branches (depending on what the host's CPU supports).</p>
        <h3>C# 11's Vector</h3>
        <p>With C# 11 you don't have to write the code above anymore because the <span class="code-inline">Vector</span> classes have their own operators and utility functions now! It's a small change that has a massive impact on readability and maintainability. The vectorized version is now on par with the scalar version in terms of readability, and even a little shorter. Since it was so easy to make the entire class vectorized, I also changed the ARGB values to be of type <span class="code-inline">Vector128&lt;float&gt;</span> internally and provide getters instead, which yielded additional performance improvements. The <span class="code-inline">Unsafe</span> methods seem to not be zero cost like I thought initially. Generic Math (also new in C# 11, not shown here) was a breeze to implement.</p>
        <div class="code">
            <p class="indent-0">public readonly struct Color</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">private readonly Vector128&lt;float&gt; argb;</p>
            <br>
            <p class="indent-1">public Vector128&lt;float&gt; Vector => argb;</p>
            <br>
            <p class="indent-1">public float A => argb.GetElement(0);</p>
            <p class="indent-1">public float R => argb.GetElement(1);</p>
            <p class="indent-1">public float G => argb.GetElement(2);</p>
            <p class="indent-1">public float B => argb.GetElement(3);</p>
            <br>
            <p class="indent-1">public Color AlphaBlend(Color top) =></p>
            <p class="indent-2">new(Vector * Vector128.Create(1.0f - top.A) + top.Vector);</p>
            <br>
            <p class="indent-1">public bool Equals(Color other) => Vector == other.Vector;</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>Are there still functions that cannot be implemented this way? Would it be even faster to <span class="code-inline">MemoryMarshal.Cast</span> an array of colors to a <span class="code-inline">Vector256&lt;float&gt;</span>? Of course. But the next time you write a simple container of homogenous data, stop and think for a second if you could express it as a <span class="code-inline">Vector</span> internally. Maybe someone will thank you for your extra care someday, or at least learn something new while looking through your source code.</p>
    </div>

    <div class="textarea" id="haskell-io">
        <h2>Haskell was right</h2>
        <p>It's somewhat ironic that many programmers think that the (IO) monad is overly complicated and solves problems that could only ever exist in a pure lazy functional programming language; Yet, at the same time, are convinced that the following code should be considered good practice:</p>
        <div class="code">
            <p class="indent-0">public interface IProcessor</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">async Task<...> ProcessData(int id);</p>
            <p class="indent-0">&rbrace;</p>
            <br/>
            <p class="indent-0">public class Processor : IProcessor</p>
            <p class="indent-0">&lbrace;</p>
            <p class="indent-1">private readonly IDbConnector dbConnector;</p>
            <br/>
            <p class="indent-1">public async Task<...> ProcessData(int id)</p>
            <p class="indent-1">&lbrace;</p>
            <p class="indent-2">var data = await dbConnector.QueryAsync(id);</p>
            <p class="indent-2">return TransformData(data);</p>
            <p class="indent-1">&rbrace;</p>
            <p class="indent-0">&rbrace;</p>
        </div>
        <p>... where IO is explicitly marked in three different places.</p>
        <p>- <span class="code-inline">async</span> because you do not want your app to lag or your web server run out of threads. There are very few cases where <span class="code-inline">async</span> does not imply IO.</p>
        <p>- <span class="code-inline">IDbConnector</span> because you might want to mock IO away for testing. Or use a different database later on... because that always works without breaking changes...</p>
        <p>- <span class="code-inline">IProcessor</span> because Dependency Injection is the best thing since sliced bread and correctly mocking a database connector is hard.</p>
        <br>
        <p>Of course, all of this is less general than monads and you will be changing the <span class="code-inline">IProcessor</span> interface every time you add or remove a method from<span class="code-inline">Processor</span>. This code is not and never was about composability or API stability, it's a mess of bandaids for the underlying problems that come with IO. You just accepted it as "clean code" because everyone else does the same thing.</p>
        <p>Academia has good reasons for handling things in a certain way and we should build on their foundations, not ignore them.</p>
    </div>
    
    <div class="textarea" id="about-me">
        <h2>About</h2>
        <p>Hi! I'm Philipp, a software developer based in Munich, Germany. While my daily work is mostly full stack development, my interests reach far beyond that, including programming language research, low level optimizations and game engines. Outside of computer science there's also painting and photography, which are huge hobbies, too.</p>
    </div>
  </body>
</html>
